/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar lenguaG.cup
 **/

/**
 * Asignatura: 21780 - Compiladores
 * Miembros:
 * 	- Román Colom, Marc
 * 	- Korn, Andreas Manuel
 * 	- Vilella Candia, Joan 
 */
// Si estás en Lexic.java, OJO! Este archivo no debe ser modificado manualmente: para hacer cambios hacerlo en lenguaG.flex 
// y luego seleccionar dicho archivo como input de jflex en "lexical specification". El output se debe dejar tal cual.
package lenguag.sintactic;

import java_cup.runtime.*;
import lenguag.sintactic.symbols.*;

class Parser;

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
parser code {:
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
:}
**/

/**
 ** També aquí es poden afegir accions a realitzar quan es requereix un token.
scan with {:     next_token(); :}
**/

// Symbols

terminal                        RES_MAIN, CONSTANT;
terminal                        L_PAREN, R_PAREN, L_KEY, R_KEY;
non terminal    SymbolBody      BODY;
non terminal    SymbolDecs      DECLARATIONS;
non terminal    SymbolMain      MAIN;
non terminal    SymbolArgs      ARGS;
non terminal    SymbolInstrs    INSTRUCTIONS;
non terminal    SymbolDec       DECLARATION;
non terminal    SymbolFunc      FUNCTION;

/*terminal                ADD, SUB, MUL, DIV, MOD, LPAREN, RPAREN;
terminal      String    valor;
non terminal  SymbolE   E;
non terminal  SymbolEp  Ep;
non terminal  SymbolT   T;
non terminal  SymbolTp  Tp;
non terminal  SymbolF   F;


precedence left  ADD, SUB;
precedence left  MUL, DIV, MOD;*/

start with BODY;

BODY ::=  DECLARATIONS:v1 MAIN:v2     {: RESULT = new SymbolBody(v1, v2); :};

/*
BODY -> DECLARATIONS MAIN.

MAIN -> main L_PAREN ARGS R_PAREN L_KEY INSTRUCTIONS R_KEY.

DECLARATIONS -> DECLARATION DECLARATIONS 
    | FUNCTION DECLARATIONS 
    | .

DECLARATION -> CONSTANT CONT_DECLARATION
    | CONT_DECLARATION.

CONT_DECLARATION ->	TYPE VARIABLE INITIALIZATION
    | TYPE VARIABLE.

INITIALIZATION -> EQUAL EXPRESSION.

FUNCTION -> TYPE VARIABLE L_PAREN ARGS R_PAREN L_KEY INSTRUCTIONS R_KEY.

ARGS -> ARG MORE_ARGS
    | .

MORE_ARGS -> COMMA ARG
    | .

ARG -> TYPE VARIABLE.

INSTRUCTIONS -> INSTRUCTION INSTRUCTIONS
    | .

INSTRUCTION -> DECLARATION ENDLINE
    | ASSIGNATION ENDLINE
    | SWAP ENDLINE
    | FUNCTION_CALL ENDLINE
    | RETURN ENDLINE
    | IF
    | LOOP
    | FOR
    | IN
    | OUT.

ASSIGNATION -> VARIABLE EQUAL OPERATION 
    | VARIABLE EQUAL EXPRESSION.

SWAP -> VARIABLE <<>> VARIABLE.

EXPRESSION -> VALUE
    | L_PAREN EXPRESSION R_PAREN
    | L_PAREN OPERATION R_PAREN
    | NOT EXPRESSION.

OPERATION -> EXPRESSION ADDITION
    | EXPRESSION SUBSTRACTION
    | EXPRESSION PRODUCT
    | EXPRESSION DIVISION
    | EXPRESSION MODULE
    | EXPRESSION OR
    | EXPRESSION AND
    | EXPRESSION OP_REL.

ADDITION -> + EXPRESSION.

SUBSTRACTION -> - EXPRESSION.

PRODUCT -> * EXPRESSION.

DIVISION -> / EXPRESSION.

MODULE -> % EXPRESSION.

OR -> or EXPRESSION.

AND -> and EXPRESSION.

OP_REL -> EQUALS
    | BIGGER
    | BEQ
    | LESSER
    | LEQ
    | NEQ.

EQUALS -> == EXPRESSION.

BIGGER -> > EXPRESSION.

BEQ -> >= EXPRESSION.

LESSER -> < EXPRESSION.

LEQ -> <= EXPRESSION.

NEQ -> != EXPRESSION.

VALUE -> VARIABLE
    | FIXED_VALUE
    | FUNCTION_CALL.

VARIABLE -> IDENTIFIER ARRAY_SUFFIX.

ARRAY_SUFFIX -> L_BRACKET VARIABLE R_BRACKET ARRAY_SUFFIX # variable must be integer
    | .

FIXED_VALUE -> INTEGER
    | CHARACTER
    | LIST
    | BOOLEAN.

TYPE -> TYPE_INTEGER ARRAY_SUFFIX
    | TYPE_FLOAT ARRAY_SUFFIX
    | TYPE_CHARACTER ARRAY_SUFFIX
    | TYPE_BOOLEAN ARRAY_SUFFIX.

LIST -> L_BRACKET VALUE CONT_LIST.
CONT_LIST -> COMMA VALUE CONT_LIST
    | R_BRACKET.

CONDITION -> EXPRESSION
    | OPERATION.

IF -> if L_PAREN CONDITION R_PAREN L_KEY INSTRUCTIONS R_KEY ELSE.
ELSE -> else if L_PAREN CONDITION R_PAREN L_KEY INSTRUCTIONS R_KEY ELSE
    | else L_KEY CONDITION R_KEY
    | .

LOOP -> while L_PAREN CONDITION R_PAREN L_KEY INSTRUCTIONS R_KEY.

FOR -> FOR_HEADER L_KEY INSTRUCTIONS R_KEY.

FOR_HEADER -> for L_PAREN HEADER_SEGMENT ENDLINE CONDITION ENDLINE HEADER_SEGMENT R_PAREN.

HEADER_SEGMENT -> DECLARATION 
    | ASSIGNATION 
    | SWAP 
    | FUNCTION_CALL. # Quitar si no implementamos pasar por referencia

FUNCTION_CALL -> VARIABLE L_PAREN PARAMS R_PAREN.

PARAMS -> PARAM MORE_PARAMS
    | .

MORE_PARAMS -> COMMA PARAM
    | .

PARAM -> VALUE.

RETURN -> return EXPRESSION
    | return OPERATION
    | return.

IN -> in L_PAREN PARAM R_PAREN.

OUT -> out L_PAREN PARAM R_PAREN.
************************************************************************************************************************************
E ::=  T:v1 Ep:v2       {: RESULT = new SymbolE((Integer)v1.value, v2);  :}
     ;

Ep ::= ADD T:v1 Ep:v2   {: RESULT = new SymbolEp(ParserSym.ADD, (Integer)v1.value, v2); :}
     | SUB T:v1 Ep:v2   {: RESULT = new SymbolEp(ParserSym.SUB, (Integer)v1.value, v2); :} 
     |                  {: RESULT = new SymbolEp(); :}
     ;


T ::=  F:v1 Tp:v2       {: RESULT = new SymbolT((Integer)v1.value, v2);     :}
     ;

Tp ::= MUL F:v1 Tp:v2   {: RESULT = new SymbolTp(ParserSym.MUL, (Integer)v1.value, v2); :}
     | DIV F:v1 Tp:v2   {: RESULT = new SymbolTp(ParserSym.DIV, (Integer)v1.value, v2); :}
     | MOD F:v1 Tp:v2   {: RESULT = new SymbolTp(ParserSym.MOD, (Integer)v1.value, v2); :}
     |                  {: RESULT = new SymbolTp(); :}
     ;

F ::= LPAREN E:v RPAREN {: RESULT = new SymbolF((Integer)v.value);     :}
     | valor:v          {: RESULT = new SymbolF(Integer.parseInt(v));  :}
     ;*/