/**
 * Asignatura: 21780 - Compiladores
 * Miembros:
 * 	- Román Colom, Marc
 * 	- Korn, Andreas Manuel
 * 	- Vilella Candia, Joan 
 *********************************************************
 * Para compilar este código es necesario hacerlo con CUP:
 *
 * java -jar java-cup-11b.jar lenguaG.cup
 */
package lenguag.syntactic;

import lenguag.syntactic.symbols.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;

class Parser;

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
parser code {:
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
:}
**/
parser code {:

    /**
     * error treatment methods override 
     **/

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_error("Catastrophical syntactical error", cur_token);
        done_parsing();        
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("Syntactical error", cur_token);
    }

    @Override
    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder("ERROR");
        if (info instanceof Symbol) {
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();
            
            if (l != null) {
                msg.append(" (fila: ")
                   .append(l.getLine())
                   .append(", columna: ")
                   .append(l.getColumn())
                   .append(")");
            }
        }
        msg.append(": ").append(message);
        
        System.err.println(msg);
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Catastrophical error ("+message+")", info);
        done_parsing();
    }

:};

/**
 ** També aquí es poden afegir accions a realitzar quan es requereix un token.
scan with {:     next_token(); :}
**/

// Symbols

terminal                        RES_MAIN, CONSTANT, NOT, TYPE_INTEGER, TYPE_CHARACTER, TYPE_BOOLEAN, TYPE_VOID;
terminal                        RES_IF, RES_ELSE, RES_WHILE, RES_FOR, RES_RETURN, RES_IN, RES_OUT;
terminal                        L_PAREN, R_PAREN, L_KEY, R_KEY, L_BRACKET, R_BRACKET, EQUAL, COMMA, ENDLINE;
terminal                        OP_SWAP, ADD, SUB, PROD, DIV, MOD, OR, AND, IS_EQUAL, BIGGER, BEQ, LESSER, LEQ, NEQ;
terminal     String             IDENTIFIER;
terminal     Integer            INTEGER;
// terminal     Float              FLOAT;
terminal     Character          CHARACTER;
terminal     Boolean            BOOLEAN;
terminal     String             STRING;
non terminal SymbolBody         BODY;
non terminal SymbolDecs         DECLARATIONS;
non terminal SymbolDec          DECLARATION;
non terminal SymbolDecCont      CONT_DECLARATION;
non terminal SymbolMain         MAIN;
non terminal SymbolArgs         ARGS, MORE_ARGS;
non terminal SymbolArg          ARG;
// non terminal SymbolMoreArgs     MORE_ARGS;
non terminal SymbolInstrs       INSTRUCTIONS;
non terminal SymbolInstr        INSTRUCTION;
non terminal SymbolFunc         FUNCTION;
non terminal SymbolType         TYPE;
non terminal SymbolVar          VARIABLE;
non terminal SymbolExpr         EXPRESSION;
non terminal SymbolAssign       ASSIGNATION;
non terminal SymbolSwap         SWAP;
non terminal SymbolReturn       RETURN;
non terminal SymbolIn           IN;
non terminal SymbolOut          OUT;
non terminal SymbolOper         OPERATION;
non terminal SymbolValue        VALUE;
non terminal SymbolOp           OP;
non terminal SymbolOpRel        OP_REL;
// non terminal SymbolFixedVal     FIXED_VALUE;
non terminal Object             FIXED_VALUE;
non terminal SymbolArrSuff      ARRAY_SUFFIX;
non terminal SymbolList         LIST, CONT_LIST;
// non terminal SymbolContList     CONT_LIST;
non terminal SymbolCond         CONDITION;
non terminal SymbolIf           IF;
non terminal SymbolElse         ELSE;
non terminal SymbolLoop         LOOP;
non terminal SymbolFor          FOR;
// non terminal SymbolForHeader    FOR_HEADER;
non terminal SymbolHeaderSeg    HEADER_SEGMENT;
non terminal SymbolFuncCall     FUNCTION_CALL;
non terminal SymbolParams       PARAMS, MORE_PARAMS;
// non terminal SymbolParam        PARAM;
// non terminal SymbolMoreParams   MORE_PARAMS;

precedence left  PROD, DIV, MOD, ADD, SUB;
precedence left  AND, OR;

// Grammar

start with BODY;

BODY ::= DECLARATIONS:v1 MAIN:v2                                        {: RESULT = new SymbolBody(v1, v2); :}
       ;

MAIN ::= RES_MAIN L_PAREN ARGS:v1 R_PAREN L_KEY INSTRUCTIONS:v2 R_KEY   {: RESULT = new SymbolMain(v1, v2); :}
       ;

DECLARATIONS ::= DECLARATION:v1 ENDLINE DECLARATIONS:v2                 {: RESULT = new SymbolDecs(v1, v2); :}
               | FUNCTION:v1 DECLARATIONS:v2                            {: RESULT = new SymbolDecs(v1, v2); :}
               |                                                        {: RESULT = new SymbolDecs(); :}
               ;
//               | error ENDLINE                                            {: RESULT = null /*Error treatment*/ :}
//               | error R_KEY                                              {: RESULT = null /*Error treatment*/ :}

DECLARATION ::= CONSTANT CONT_DECLARATION:v                             {: RESULT = new SymbolDec(v, true); :}
              | CONT_DECLARATION:v                                      {: RESULT = new SymbolDec(v); :}
              ;

CONT_DECLARATION ::= TYPE:v1 VARIABLE:v2 EQUAL EXPRESSION:v3            {: RESULT = new SymbolDecCont(v1, v2, v3); :}
                   | TYPE:v1 VARIABLE:v2 EQUAL OPERATION:v3             {: RESULT = new SymbolDecCont(v1, v2, v3); :}
                   | TYPE:v1 VARIABLE:v2                                {: RESULT = new SymbolDecCont(v1, v2); :}
                   ;

FUNCTION ::= TYPE:v1 VARIABLE:v2 L_PAREN ARGS:v3 R_PAREN L_KEY INSTRUCTIONS:v4 R_KEY 
                                                                        {: RESULT = new SymbolFunc(v1, v2, v3, v4); :}
           ;

ARGS ::= ARG:v1 MORE_ARGS:v2                                            {: RESULT = new SymbolArgs(v1, v2); :}
       |                                                                {: RESULT = new SymbolArgs(); :}
       ;

MORE_ARGS ::= COMMA ARG:v1 MORE_ARGS:v2                                 {: RESULT = new SymbolArgs(v1, v2); :}
            |                                                           {: RESULT = new SymbolArgs(); :}
            ;

ARG ::= TYPE:v1 VARIABLE:v2                                             {: RESULT = new SymbolArg(v1, v2); :}
      ;

INSTRUCTIONS ::= INSTRUCTION:v1 INSTRUCTIONS:v2                         {: RESULT = new SymbolInstrs(v1, v2); :}
               |                                                        {: RESULT = new SymbolInstrs(); :}
               ;

INSTRUCTION ::= DECLARATION:v ENDLINE                                   {: RESULT = new SymbolInstr(v); :}
              | ASSIGNATION:v ENDLINE                                   {: RESULT = new SymbolInstr(v); :}
              | SWAP:v ENDLINE                                          {: RESULT = new SymbolInstr(v); :}
              | FUNCTION_CALL:v ENDLINE                                 {: RESULT = new SymbolInstr(v); :}
              | RETURN:v ENDLINE                                        {: RESULT = new SymbolInstr(v); :}
              | IF:v                                                    {: RESULT = new SymbolInstr(v); :}
              | LOOP:v                                                  {: RESULT = new SymbolInstr(v); :}
              | FOR:v                                                   {: RESULT = new SymbolInstr(v); :}
              | IN:v ENDLINE                                            {: RESULT = new SymbolInstr(v); :}
              | OUT:v ENDLINE                                           {: RESULT = new SymbolInstr(v); :}
              ;
//              | error ENDLINE                                                     {: RESULT = null /*Error treatment*/ :}
//              | error R_KEY                                                       {: RESULT = null /*Error treatment*/ :};

ASSIGNATION ::= VARIABLE:v1 EQUAL OPERATION:v2                          {: RESULT = new SymbolAssign(v1, v2); :} 
              | VARIABLE:v1 EQUAL EXPRESSION:v2                         {: RESULT = new SymbolAssign(v1, v2); :}
              ;

SWAP ::= VARIABLE:v1 OP_SWAP VARIABLE:v2                                {: RESULT = new SymbolSwap(v1, v2); :}
       ;

EXPRESSION ::= VALUE:v                                                  {: RESULT = new SymbolExpr(v); :}
             | L_PAREN EXPRESSION:v R_PAREN                             {: RESULT = new SymbolExpr(v); :}
             | L_PAREN OPERATION:v R_PAREN                              {: RESULT = new SymbolExpr(v); :}
             | NOT EXPRESSION:v1                                        {: RESULT = new SymbolExpr(v1, false); :}
             ;

OPERATION ::= EXPRESSION:v1 OP:v2 EXPRESSION:v3                         {: RESULT = new SymbolOper(v1, v2, v3) :}
            ;

OP ::= ADD                                                              {: RESULT = new SymbolOp(ParserSym.ADD); :}
     | SUB                                                              {: RESULT = new SymbolOp(ParserSym.SUB); :}
     | PROD                                                             {: RESULT = new SymbolOp(ParserSym.PROD); :}
     | DIV                                                              {: RESULT = new SymbolOp(ParserSym.DIV); :}
     | MOD                                                              {: RESULT = new SymbolOp(ParserSym.MOD); :}
     | OR                                                               {: RESULT = new SymbolOp(ParserSym.OR); :}
     | AND                                                              {: RESULT = new SymbolOp(ParserSym.AND); :}
     | OP_REL:v                                                         {: RESULT = new SymbolOp(v); :}
     ;

OP_REL ::= IS_EQUAL                                                     {: RESULT = new SymbolOpRel(ParserSym.IS_EQUAL); :}
         | BIGGER                                                       {: RESULT = new SymbolOpRel(ParserSym.IS_EQUAL); :}
         | BEQ                                                          {: RESULT = new SymbolOpRel(ParserSym.BEQ); :}
         | LESSER                                                       {: RESULT = new SymbolOpRel(ParserSym.LESSER); :}
         | LEQ                                                          {: RESULT = new SymbolOpRel(ParserSym.LEQ); :}
         | NEQ                                                          {: RESULT = new SymbolOpRel(ParserSym.NEQ); :}
         ;

VALUE ::= VARIABLE:v                                                    {: RESULT = new SymbolValue(v); :}
        | FIXED_VALUE:v                                                 {: RESULT = new SymbolValue(v); :}
        | FUNCTION_CALL:v                                               {: RESULT = new SymbolValue(v); :}
        ;

VARIABLE ::= IDENTIFIER:v1 ARRAY_SUFFIX:v2                              {: RESULT = new SymbolVar(v1, v2); :}
           ;

ARRAY_SUFFIX ::= L_BRACKET VARIABLE:v1 R_BRACKET ARRAY_SUFFIX:v2        {: RESULT = new SymbolArrSuff(v1, v2); :}
               |                                                        {: RESULT = new SymbolArrSuff(); :}
               ;

FIXED_VALUE ::= INTEGER:v                                               {: RESULT = v; /* Returns Integer */ :} 
              | CHARACTER:v                                             {: RESULT = v; /* Returns Character */ :}
              | LIST:v                                                  {: RESULT = v; /* Returns SymbolList */ :}
              | BOOLEAN:v                                               {: RESULT = v; /* Returns Integer */ :}
              ;
            //   | FLOAT:v                                                 {: RESULT = v; /* Returns Float */ :}

TYPE ::= TYPE_INTEGER ARRAY_SUFFIX:v                                    {: RESULT = new SymbolType(ParserSym.TYPE_INTEGER, v); :}
       | TYPE_CHARACTER ARRAY_SUFFIX:v                                  {: RESULT = new SymbolType(ParserSym.TYPE_CHARACTER, v); :}
       | TYPE_BOOLEAN ARRAY_SUFFIX:v                                    {: RESULT = new SymbolType(ParserSym.TYPE_BOOLEAN, v); :}
       | TYPE_VOID                                                      {: RESULT = new SymbolType(ParserSym.TYPE_VOID); :}
       ;
    //    | TYPE_FLOAT ARRAY_SUFFIX:v                                      {: RESULT = new SymbolType(ParserSym.TYPE_FLOAT, v); :}

LIST ::= L_BRACKET VALUE:v1 CONT_LIST:v2                                {: RESULT = new SymbolList(v1, v2); :}
       ;
//       | STRING;     // TODO maybe

CONT_LIST ::= COMMA VALUE:v1 CONT_LIST:v2                               {: RESULT = new SymbolList(v1, v2); :}
            | R_BRACKET                                                 {: RESULT = new SymbolList(); :}
            ;
//            | error R_BRACKET;

CONDITION ::= EXPRESSION:v                                              {: RESULT = new SymbolCond(v); :}
            | OPERATION:v                                               {: RESULT = new SymbolCond(v); :}
            ;

IF ::= RES_IF L_PAREN CONDITION:v1 R_PAREN L_KEY INSTRUCTIONS:v2 R_KEY ELSE:v3 
                                                                        {: RESULT = new SymbolIf(v1, v2, v3); :}
     ;

ELSE ::= RES_ELSE IF:v                                                  {: RESULT = new SymbolElse(v); :}
       | RES_ELSE L_KEY INSTRUCTIONS R_KEY                              {: RESULT = new SymbolElse(v); :}
       |                                                                {: RESULT = new SymbolElse(); :}
       ;

LOOP ::= RES_WHILE L_PAREN CONDITION:v1 R_PAREN L_KEY INSTRUCTIONS:v2 R_KEY 
                                                                        {: RESULT = new SymbolLoop(v1, v2); :}
       ;

FOR ::= RES_FOR L_PAREN HEADER_SEGMENT:v1 ENDLINE CONDITION:v2 ENDLINE HEADER_SEGMENT:v3 R_PAREN L_KEY INSTRUCTIONS:v4 R_KEY
                                                                        {: RESULT = new SymbolFor(v1, v2, v3, v4); :}
      ;

HEADER_SEGMENT ::= DECLARATION:v                                        {: RESULT = new SymbolHeaderSeg(v); :}
                 | ASSIGNATION:v                                        {: RESULT = new SymbolHeaderSeg(v); :}
                 | SWAP:v                                               {: RESULT = new SymbolHeaderSeg(v); :}
                 | FUNCTION_CALL:v                                      {: RESULT = new SymbolHeaderSeg(v); :}
                 ; 
                    // ^- Quitar FUNCTION_CALL si no implementamos pasar por referencia

FUNCTION_CALL ::= VARIABLE:v1 L_PAREN PARAMS:v2 R_PAREN                 {: RESULT = new SymbolFuncCall(v1, v2); :}
                ;

// PARAMS ::= PARAM:v1 MORE_PARAMS:v2                                      {: RESULT = new SymbolParams(v1, v2); :}
PARAMS ::= VALUE:v1 MORE_PARAMS:v2                                      {: RESULT = new SymbolParams(v1, v2); :}
         |                                                              {: RESULT = new SymbolParams(); :}
         ;

// MORE_PARAMS ::= COMMA PARAM:v1 MORE_PARAMS:v2                           {: RESULT = new SymbolParams(v1, v2); :}
MORE_PARAMS ::= COMMA VALUE:v1 MORE_PARAMS:v2                           {: RESULT = new SymbolParams(v1, v2); :}
              |                                                         {: RESULT = new SymbolParams(); :}
              ;

RETURN ::= RES_RETURN EXPRESSION:v                                      {: RESULT = new SymbolReturn(v); :}
         | RES_RETURN OPERATION:v                                       {: RESULT = new SymbolReturn(v); :}
         | RES_RETURN                                                   {: RESULT = new SymbolReturn(); :}
         ;

IN ::= RES_IN L_PAREN VARIABLE:v R_PAREN                                {: RESULT = new SymbolIn(v); :}
     ;

OUT ::= RES_OUT L_PAREN VALUE:v R_PAREN                                 {: RESULT = new SymbolOut(v); :}
      ;

/************************************************************************************************************************************
E ::=  T:v1 Ep:v2       {: RESULT = new SymbolE((Integer)v1.value, v2);  :}
     ;

Ep ::= ADD T:v1 Ep:v2   {: RESULT = new SymbolEp(ParserSym.ADD, (Integer)v1.value, v2); :}
     | SUB T:v1 Ep:v2   {: RESULT = new SymbolEp(ParserSym.SUB, (Integer)v1.value, v2); :} 
     |                  {: RESULT = new SymbolEp(); :}
     ;


T ::=  F:v1 Tp:v2       {: RESULT = new SymbolT((Integer)v1.value, v2);     :}
     ;

Tp ::= MUL F:v1 Tp:v2   {: RESULT = new SymbolTp(ParserSym.MUL, (Integer)v1.value, v2); :}
     | DIV F:v1 Tp:v2   {: RESULT = new SymbolTp(ParserSym.DIV, (Integer)v1.value, v2); :}
     | MOD F:v1 Tp:v2   {: RESULT = new SymbolTp(ParserSym.MOD, (Integer)v1.value, v2); :}
     |                  {: RESULT = new SymbolTp(); :}
     ;

F ::= LPAREN E:v RPAREN {: RESULT = new SymbolF((Integer)v.value);     :}
     | valor:v          {: RESULT = new SymbolF(Integer.parseInt(v));  :}
     ;*/