/**
 * Asignatura: 21780 - Compiladores
 * Miembros:
 * 	- Korn, Andreas Manuel
 * 	- Román Colom, Marc
 * 	- Vilella Candía, Joan 
 */
package lenguag.backend;

import java.util.ArrayList;
import java.util.Hashtable;

import lenguag.Constants;
import lenguag.LenguaG;
import lenguag.syntactic.symbols.*;
import lenguag.backend.Instruction.InstructionType;

public class IntermediateCodeGenerator {

    private ArrayList<Instruction> c3a;

    private Hashtable<String, VarTableEntry> variableTable;
    private Hashtable<String, ProcTableEntry> procedureTable;
    private Hashtable<String, Integer> eList;
    
    private String currentFunction;
    
    private String currentDec; // Variable used in array declaration
    private int currentDecLength;
    private ArrayList<Integer> dimensionsToCheck;

    private int numE;
    private int numT;
   
    public IntermediateCodeGenerator(){
        c3a = new ArrayList<>();
        variableTable = new Hashtable<>();
        procedureTable = new Hashtable<>();
        numE = 0;
        numT = 0;
        currentFunction = "."; // We use the format function.variable to store and access the variable table
        // This avoids the very real possibility of the user creating a variable of format tN (where N is a natural) 
        // which would cause undesired behaviour
        currentDecLength = -1;
    }

    /**
     * Starts the intermediate code generation. 
     * @param body - The root node of what should be the whole tree generated by the parser and which has been analyzed by the semantic analyzer.
     */
    public void generate(SymbolBody body){
        // No code is generated here, equal to its semantic.manage() equivalent
        SymbolDecs decs = body.getDeclarations();
        if(decs != null) generate(decs);
        SymbolMain main = body.getMain();
        generate(main);

        if(LenguaG.DEBUGGING) {
            for (String s : variableTable.keySet()) {
                System.out.println(s + ": " + variableTable.get(s).tName);            
            }
        }
    }
    
    /**
     * Arg: getType(), identifier
     * @param arg
     */
    private void generate(SymbolArg arg){
        String t = "";
        
        arg.reference = t;
    }

    /**
     * Args: getArg(), getNext()
     * @param args
     */
    private void generate(SymbolArgs args){

    }

    /**
     * ArrSuff: getIndex(), getNext(), getDimensions()
     * @param arrSuff
     * @param vte - Variable Table Entry to manage array dimensions
     */
    private void generate(SymbolArrSuff arrSuff){
        // if first 
        //     t1 = i = arrSuff.reference = getIndex().reference;
        // else 
        //     t2 = t1 * d2 
        //     t3 = t2 + i2
        // end if
        // Our grammar does not allow us to differentiate between the first and the middle array suffixes
        // So we can generalize it by saying
        // foreach n
        //      t(n+1) = t(n) * d(n)
        //      t(n+2) = t(n+1) + i(n)
        // Where t(1) = 0. This is why if it's the first time calling this function, tn is 0
        String tn = arrSuff.reference == null ? "0" : arrSuff.reference; // Why tn is this symbol's reference is further explained in a few lines
        //String tn = index.reference;
        int dimensions = dimensionsToCheck.remove(0);
        System.out.println(dimensions);
        String tn1 = newVariable();
        addInstruction(InstructionType.prod, tn, ""+dimensions, tn1); // tn1 = tn * d
        SymbolOperation index = arrSuff.getIndex();
        generate(index);
        String in = index.reference;
        String tn2 = newVariable();
        addInstruction(InstructionType.add, tn1, in, tn2); // tn2 = tn1 + in
        
        // Next iteration
        SymbolArrSuff next = arrSuff.getNext();
        if(next != null){
            next.reference = tn2; // We pass tn2 as a reference. This is a "cheat" to allow communication between father and son, but is
            // technically a devirtualization of the idea of the reference. 
            // This is also the reason why at the start of this function we had to check if the reference was null or not, as only the first iteration
            // should be null
            generate(next);
            tn2 = next.reference;
        }

        arrSuff.reference = tn2;
    }

    /**
     * Assign: getVariable(), getRightSide()
     * @param assign
     */
    private void generate(SymbolAssign assign){
        String t = newVariable();

        assign.reference = t;
    }

    /**
     * Declaration: isConstant, variableName, getType(), getValue()
     * @param dec
     */
    private void generate(SymbolDec dec){
        String t = newVariable();
        currentDec = dec.variableName;
        if(dec.isConstant){
            addInstruction(InstructionType.copy, dec.getValue().getSemanticValue().toString(), t);
            replaceVarTableKey(t, dec.variableName);
            return;
        }
        replaceVarTableKey(t, dec.variableName);
        SymbolOperation value = dec.getValue();
        if(value != null){
            generate(value);
            if(!t.equals(value.reference)) addInstruction(InstructionType.copy, value.reference, t);
        }
        dec.reference = t;
        currentDec = null;
        currentDecLength = -1;
    }

    /**
     * Decs: Dec/Func, Decs.1
     * @param decs
     */
    private void generate(SymbolDecs decs){
        // No code is generated here, equal to its semantic.manage() equivalent
        SymbolBase dec = decs.getDeclaration();
        if(dec instanceof SymbolDec) generate((SymbolDec) dec);
        else if (dec instanceof SymbolFunc) {
            String eContDecs = newTag();
            addInstruction(InstructionType.go_to, eContDecs); // We must skip the function during executions unless called
            generate((SymbolFunc) dec);
            addInstruction(InstructionType.skip, eContDecs);
        }
        
        SymbolDecs nextDecs = decs.getNext();
        if (nextDecs != null) generate(nextDecs);
    }

    /**
     * sElse: getIf() | getInstructions()
     * @param sElse
     */
    private void generate(SymbolElse sElse){

    }

    /**
     * sFor: getInit(), getCondition(), getFinal(), getInstructions()
     * @param sFor
     */
    private void generate(SymbolFor sFor){
        
    }

    /**
     * Function: getType(), getFunctionName(), getArgs(), getInstructions()
     * @param func
     */
    private void generate(SymbolFunc func){
        
    }

    /**
     * functionCall: getFunctionName(), getNParams(), getParams()
     * @param functionCall
     */
    private void generate(SymbolFuncCall functionCall){
        String t = newVariable();

        functionCall.reference = t;
    }

    /**
     * sIf: getCondition(), getInstructions(), getElse()
     * @param sIf
     */
    private void generate(SymbolIf sIf){
        
    }

    private void generate(SymbolIn in){
        String t = newVariable();

        in.reference = t;
    }

    /**
     * Instruction: instructionType
     * @param instruction
     */
    private void generate(SymbolInstr instruction){
        String t = newVariable();

        instruction.reference = t;
    }

    /**
     * Instructions: getInstruction(), getNext()
     * @param instructions
     */
    private void generate(SymbolInstrs instructions){
        
    }

    /**
     * List: getValue(), getNext(), length
     * @param list
     */
    private void generate(SymbolList list){
        String t;
        VarTableEntry vte = null;
        // This is to deal with the indexing of the lists
        if(currentDec != null){
            vte = getVar(currentDec);
            t = vte.tName;
        } else  t = newVariable();
        String right = "";

        int length = list.type.arrayLength;
        // We store the dimensions of the list inside of the variable table
        if(vte != null && length != Constants.UNKNOWN){
            if(vte.dimensions.size() <= list.type.getArrayDepth()){
                vte.dimensions.add(length);
            }
        }

        SymbolOperation value = list.getValue();
        if(!value.isConstant) { 
            generate(value);
            right = value.reference;
        } else if(value.getSemanticValue() instanceof Character){
            char cVal = (Character) value.getSemanticValue();
            right = "" + (int) cVal; // We store ASCII value
            getVar(t).type = Constants.TYPE_CHARACTER;
        } else if(value.getSemanticValue() instanceof Boolean){
            boolean bVal = (Boolean) value.getSemanticValue();
            // We store true or false in bits, not in Boolean
            right = "" + (bVal ? Constants.TRUE : Constants.FALSE);
        } else if(value.getSemanticValue() instanceof Integer){
            right = "" + (int) value.getSemanticValue();
            getVar(t).occupation = Constants.INTEGER_BYTES;
        }
        
        // If the depth is 1 it means we are now on the "ground level" of the array and we can start to assign
        if(list.type.getArrayDepth() == 1){
            currentDecLength++;
            // We must store the generated values as an index of the first one, t.
            int size = Constants.CHAR_BYTES;
            if(value.type.isType(Constants.TYPE_INTEGER)) size = Constants.INTEGER_BYTES;
            int displacement = currentDecLength * size;
            addInstruction(InstructionType.ind_ass, ""+displacement, right, getVar(t).tName);
        }

        SymbolList next = list.getNext();
        if(next != null && next.getValue() != null) {
            generate(next);
        }

        list.reference = t;
    }

    private void generate(SymbolLoop loop){
        
    }

    /**
     * Main: getInstructions()
     * @param main
     */
    private void generate(SymbolMain main){
        
    }

    /**
     * Operand: Value/Operation, isNegated
     * @param operand
     */
    private void generate(SymbolOperand operand){
        String t = "";

        Object value = operand.getValue();

        if(!operand.isLeaf()){
            SymbolOperation operation = (SymbolOperation) operand.getValue();
            generate(operation);
            t = operation.reference;
        } else if(value instanceof SymbolValue){
            SymbolValue sValue = (SymbolValue) operand.getValue();
            generate(sValue);
            t = sValue.reference;
        } else if(value instanceof Integer){
            t = newVariable();
            addInstruction(InstructionType.copy, value.toString(), t);
            getVar(t).occupation = Constants.INTEGER_BYTES;
        } else if(value instanceof Character){
            t = newVariable();
            char cVal = (Character) value;
            // We store the ASCII value
            addInstruction(InstructionType.copy, "" + (int) cVal, t);
            getVar(t).type = Constants.TYPE_CHARACTER;
        } else if(value instanceof Boolean){
            t = newVariable();
            boolean bVal = (Boolean) value;
            // We store true or false in bits, not in Boolean
            addInstruction(InstructionType.copy, "" + (bVal ? Constants.TRUE : Constants.FALSE), t);
        }

        operand.reference = t;
    }

    /**
     * Operation: getLValue(), getOp(), getRValue().
     * @param operation
    */
    private void generate(SymbolOperation operation){
        String t;

        SymbolOperand lValue = operation.getLValue();
        generate(lValue);
        t = lValue.reference;
        SymbolOp op = operation.getOperation();
        SymbolOperand rValue = operation.getRValue();
        
        // If nothing else is needed we don't keep going.
        if(op == null || rValue == null){
            operation.reference = t;
            return;
        }

        generate(rValue);
        t = newVariable();
        String eTrue, eFalse;
        switch (op.operation) {
            case Constants.ADD:
                addInstruction(InstructionType.add, lValue.reference, rValue.reference, t);
                break;
            case Constants.SUB:
                addInstruction(InstructionType.sub, lValue.reference, rValue.reference, t);
                break;
            case Constants.PROD:
                addInstruction(InstructionType.prod, lValue.reference, rValue.reference, t);
                break;
            case Constants.DIV:
                addInstruction(InstructionType.div, lValue.reference, rValue.reference, t);
                break;
            case Constants.MOD:
                addInstruction(InstructionType.mod, lValue.reference, rValue.reference, t);
                break;
            case Constants.OR:
                addInstruction(InstructionType.or, lValue.reference, rValue.reference, t);
                break;
            case Constants.AND:    
                addInstruction(InstructionType.and, lValue.reference, rValue.reference, t);
                break;
            case Constants.IS_EQUAL:
                eTrue = newTag();
                eFalse = newTag();
                addInstruction(InstructionType.if_EQ, lValue.reference, rValue.reference, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.FALSE, t);
                addInstruction(InstructionType.go_to, eFalse);
                addInstruction(InstructionType.skip, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.TRUE, t);
                addInstruction(InstructionType.skip, eFalse);
                break;
            case Constants.BIGGER:
                eTrue = newTag();
                eFalse = newTag();
                addInstruction(InstructionType.if_GT, lValue.reference, rValue.reference, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.FALSE, t);
                addInstruction(InstructionType.go_to, eFalse);
                addInstruction(InstructionType.skip, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.TRUE, t);
                addInstruction(InstructionType.skip, eFalse);
                break;
            case Constants.BEQ:
                eTrue = newTag();
                eFalse = newTag();
                addInstruction(InstructionType.if_GE, lValue.reference, rValue.reference, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.FALSE, t);
                addInstruction(InstructionType.go_to, eFalse);
                addInstruction(InstructionType.skip, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.TRUE, t);
                addInstruction(InstructionType.skip, eFalse);
                break;
            case Constants.LESSER:
                eTrue = newTag();
                eFalse = newTag();
                addInstruction(InstructionType.if_LT, lValue.reference, rValue.reference, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.FALSE, t);
                addInstruction(InstructionType.go_to, eFalse);
                addInstruction(InstructionType.skip, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.TRUE, t);
                addInstruction(InstructionType.skip, eFalse);
                break;
            case Constants.LEQ:
                eTrue = newTag();
                eFalse = newTag();
                addInstruction(InstructionType.if_LE, lValue.reference, rValue.reference, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.FALSE, t);
                addInstruction(InstructionType.go_to, eFalse);
                addInstruction(InstructionType.skip, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.TRUE, t);
                addInstruction(InstructionType.skip, eFalse);
                break;
            case Constants.NEQ:
                eTrue = newTag();
                eFalse = newTag();
                addInstruction(InstructionType.if_NE, lValue.reference, rValue.reference, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.FALSE, t);
                addInstruction(InstructionType.go_to, eFalse);
                addInstruction(InstructionType.skip, eTrue);
                addInstruction(InstructionType.copy, ""+Constants.TRUE, t);
                addInstruction(InstructionType.skip, eFalse);
                break;
        }

        operation.reference = t;
    }

    /**
     * 
     * @param out
     */
    private void generate(SymbolOut out){
        
    }

    /**
     * Params: getValue(), getNext()
     * @param params
     */
    private void generate(SymbolParams params){
        
    }

    /**
     * sReturn: getValue()
     * @param sReturn
    */
    private void generate(SymbolReturn sReturn){
        
    }

    /**
     * Swap: getVar1(), getVar2()
     * @param swap
     */
    private void generate(SymbolSwap swap){
        
    }

    /**
     * Value: getValue(), isConstant
     * @param value
     */
    private void generate(SymbolValue value){
        Object val = value.getSemanticValue();
        String t = "";
        if(val instanceof SymbolVar) {
            SymbolVar var = (SymbolVar) val;
            generate(var);
            t = var.reference;
        } else if(val instanceof SymbolFuncCall) {
            SymbolFuncCall fcall = (SymbolFuncCall) val;
            generate(fcall);
            t = fcall.reference;
        } else if(val instanceof SymbolList) {
            SymbolList list = (SymbolList) val;
            generate(list);
            t = list.reference;
            // We calculate the total occupation on this variable, starting by the first level's length
            int occupation = list.type.arrayLength;
            SymbolType subLevel = list.type.getBaseType();
            // We go through each sublevel so that we can calculate the occupation accordingly.
            while(subLevel.getArrayDepth() > 0){
                occupation *= subLevel.arrayLength;
                subLevel = subLevel.getBaseType();
            }
            // If the occupation of a single value is different to 1, we must multiply by the single value's occupation.
            if(subLevel.isType(Constants.TYPE_INTEGER)){
                occupation *= Constants.INTEGER_BYTES;
            }
            getVar(t).occupation = occupation;
        } else if(val instanceof Integer) {
            int intValue = (Integer) val; 
            t = newVariable();
            addInstruction(InstructionType.copy, "" + intValue, t);
            getVar(t).occupation = Constants.INTEGER_BYTES;
        } else if(val instanceof Boolean) {
            boolean boolValue = (Boolean) val;
            t = newVariable();
            addInstruction(InstructionType.copy, "" + (boolValue ? Constants.TRUE : Constants.FALSE), t);
            getVar(t).occupation = Constants.BOOL_BYTES;
        } else if(val instanceof Character) {
            char cValue = (Character) val;
            t = newVariable();
            addInstruction(InstructionType.copy, "" + cValue, t);
            getVar(t).occupation = Constants.CHAR_BYTES;
            getVar(t).type = Constants.TYPE_CHARACTER;
        }
        value.reference = t;
    }

    /**
     * Var: getId(), getArrSuffix()
     * @param var
    */
    private void generate(SymbolVar var){
        VarTableEntry vte = getVar(var.getId());
        String t = vte.tName;

        SymbolArrSuff arrSuff = var.getArrSuff();
        if(arrSuff != null){
            dimensionsToCheck = vte.cloneDimensions();
            generate(arrSuff);
            String tSuffix = arrSuff.reference;
            int nBytes = 1;
            if(vte.type == Constants.TYPE_INTEGER){
                nBytes = Constants.INTEGER_BYTES;
            }
            // Here should go 
            // tn = tm - b 
            // but b is always 0 in our language, as all arrays start with 0
            // so we don't have to include it in this case.
            // t' = tSuff * nbytes
            // t'' = t[t']
            // t <- t''
            String tPrima = newVariable();
            addInstruction(InstructionType.prod, tSuffix, "" + nBytes, tPrima);
            String arrayOrigin = t;
            t = newVariable();
            addInstruction(InstructionType.ind_val, arrayOrigin, tPrima, t);
        }

        var.reference = t;
    }

    private String newVariable(){
        String t = "t" + numT++;
        VarTableEntry vte = new VarTableEntry(t);
        variableTable.put(currentFunction + t, vte);
        return t;
    }

    private String newTag(){
        return "e" + numE++;
    }

    private VarTableEntry getVar(String t){
        if(LenguaG.DEBUGGING){
            System.out.println("getting " + currentFunction + t);
            System.out.println("No problem getting " + variableTable.get(currentFunction + t).tName);
        }
        return variableTable.get(currentFunction + t);
    }
    
    private void replaceVarTableKey(String oldKey, String newKey){
        VarTableEntry vte = getVar(oldKey);
        variableTable.remove(oldKey);
        if(LenguaG.DEBUGGING) System.out.println("\tReplacing " + currentFunction + oldKey + " with " + newKey);
        variableTable.put(currentFunction + newKey, vte);
    }

    private void addInstruction(InstructionType instruction, String left, String right, String destination){
        Instruction i = new Instruction(instruction, left, right, destination);
        c3a.add(i);
    }
    
    private void addInstruction(InstructionType instruction, String left, String destination){
        Instruction i = new Instruction(instruction, left, destination);
        c3a.add(i);
    }
    
    private void addInstruction(InstructionType instruction, String destination){
        Instruction i = new Instruction(instruction, destination);
        c3a.add(i);
    }

    public String toString(){
        String s = "";
        for(Instruction i : c3a){
            s += i + "\n";
        }
        return s;
    }
}
