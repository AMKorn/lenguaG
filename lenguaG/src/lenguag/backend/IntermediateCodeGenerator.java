/**
 * Asignatura: 21780 - Compiladores
 * Miembros:
 * 	- Korn, Andreas Manuel
 * 	- Román Colom, Marc
 * 	- Vilella Candía, Joan 
 */
package lenguag.backend;

import java.util.ArrayList;

import lenguag.backend.Instruction.InstructionType;
import lenguag.semantic.SymbolDescription;
import lenguag.semantic.SymbolTable;
import lenguag.syntactic.symbols.*;

public class IntermediateCodeGenerator {

    private ArrayList<Instruction> c3a;

    private SymbolTable symbolTable;
    
    private int numE;
    private int numT;
   
    public IntermediateCodeGenerator(SymbolTable symbolTable){
        c3a = new ArrayList<>();
        numE = 0;
        numT = 0;
        this.symbolTable = symbolTable;
    }

    /**
     * Starts the intermediate code generation. 
     * @param body - The root node of what should be the whole tree generated by the parser and which has been analyzed by the semantic analyzer.
     */
    public void generate(SymbolBody body){
        // No code is generated here, equal to its semantic.manage() equivalent
        SymbolDecs decs = body.getDeclarations();
        if(decs != null) generate(decs);
        SymbolMain main = body.getMain();
        generate(main);
    }
    
    /**
     * Arg: getType(), identifier
     * @param arg
     */
    private void generate(SymbolArg arg){
    }

    /**
     * Args: getArg(), getNext()
     * @param args
     */
    private void generate(SymbolArgs args){
    }

    /**
     * ArrSuff: getIndex(), getNext(), getDimensions()
     * @param arrSuff
     */
    private void generate(SymbolArrSuff arrSuff){
    }

    /**
     * Assign: getVariable(), getRightSide()
     * @param assign
     */
    private void generate(SymbolAssign assign){

    }

    /**
     * Declaration: isConstant, variableName, getType(), getValue()
     * @param dec
     */
    private void generate(SymbolDec dec){
        SymbolDescription desc = symbolTable.getDescription(dec.variableName);
        // if(dec.isConstant){
        //     addInstruction(InstructionType.copy, dec.getValue().getSemanticValue().toString(), dec.variableName);
        // }
        // SymbolOperation value = dec.getValue();
        // generate(value);
        // String t = newVariable();
        // addInstruction(InstructionType.copy, value.r, t);
        // dec.r = t;
    }

    /**
     * Decs: Dec/Func, Decs.1
     * @param decs
     */
    private void generate(SymbolDecs decs){
        // No code is generated here, equal to its semantic.manage() equivalent
        SymbolBase dec = decs.getDeclaration();
        if(dec instanceof SymbolDec) generate((SymbolDec) dec);
        else if (dec instanceof SymbolFunc) generate((SymbolFunc) dec);
        
        SymbolDecs nextDecs = decs.getNext();
        if (nextDecs != null) generate(nextDecs);
    }

    /**
     * sElse: getIf() | getInstructions()
     * @param sElse
     */
    private void generate(SymbolElse sElse){
        
    }

    /**
     * sFor: getInit(), getCondition(), getFinal(), getInstructions()
     * @param sFor
     */
    private void generate(SymbolFor sFor){
        
    }

    /**
     * Function: getType(), getFunctionName(), getArgs(), getInstructions()
     * @param func
     */
    private void generate(SymbolFunc func){
        
    }

    /**
     * functionCall: getFunctionName(), getNParams(), getParams()
     * @param functionCall
     */
    private void generate(SymbolFuncCall functionCall){
        
    }

    /**
     * sIf: getCondition(), getInstructions(), getElse()
     * @param sIf
     */
    private void generate(SymbolIf sIf){
        
    }

    private void generate(SymbolIn in){
        
    }

    /**
     * Instruction: instructionType
     * @param instruction
     */
    private void generate(SymbolInstr instruction){
        
    }

    /**
     * Instructions: getInstruction(), getNext()
     * @param instructions
     */
    private void generate(SymbolInstrs instructions){
        
    }

    /**
     * List: getValue(), getNext(), length
     * @param list
     */
    private void generate(SymbolList list){
        
    }

    private void generate(SymbolLoop loop){
        
    }

    /**
     * Main: getInstructions()
     * @param main
     */
    private void generate(SymbolMain main){
        
    }

    /**
     * Operand: Value/Operation, isNegated
     * @param operand
     */
    private void generate(SymbolOperand operand){
        
    }

    /**
     * Operation: getLValue(), getOp(), getRValue().
     * @param operation
    */
    private void generate(SymbolOperation operation){
        
    }

    /**
     * 
     * @param out
     */
    private void generate(SymbolOut out){
        
    }

    /**
     * Params: getValue(), getNext()
     * @param params
     */
    private void generate(SymbolParams params){
        
    }

    /**
     * sReturn: getValue()
     * @param sReturn
    */
    private void generate(SymbolReturn sReturn){
        
    }

    /**
     * Swap: getVar1(), getVar2()
     * @param swap
     */
    private void generate(SymbolSwap swap){
        
    }

    /**
     * Value: getValue(), isConstant
     * @param value
     */
    private void generate(SymbolValue value){
        
    }

    /**
     * Var: getId(), getArrSuffix()
     * @param var
    */
    private void generate(SymbolVar var){
        
    }

    private String newVariable(){
        return "t" + numT++;
    }

    private String newTag(){
        return "e" + numE++;
    }

    private void addInstruction(InstructionType instruction, String left, String right, String destination){
        Instruction i = new Instruction(instruction, left, right, destination);
        c3a.add(i);
    }
    
    private void addInstruction(InstructionType instruction, String left, String destination){
        Instruction i = new Instruction(instruction, left, destination);
        c3a.add(i);
    }
    
    private void addInstruction(InstructionType instruction, String destination){
        Instruction i = new Instruction(instruction, destination);
        c3a.add(i);
    }

    public String toString(){
        String s = "";
        for(Instruction i : c3a){
            s += i + "\n";
        }
        return s;
    }
}
