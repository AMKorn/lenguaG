package lenguag.semantic;

import java.util.ArrayList;

import lenguag.LenguaGException.SemanticException;
import lenguag.syntactic.symbols.*;

public class Semantic {
    
    public SymbolTable symbolTable;

    private ArrayList<String> errors;
    public boolean thereIsError = false;

    public Semantic(){
        symbolTable = new SymbolTable();
        errors = new ArrayList<>();
    }

    /**
     * Starts the semantic analysis. There should be no possible errors in this symbol if syntactical analysis was correct.
     * Body: Declarations, Main
     * @param body - The root node of what should be the whole tree generated by the parser.
     */
    public void manage(SymbolBody body){
        SymbolDecs decs = body.getDeclarations();
        if(decs != null) manage(decs);
        SymbolMain main = body.getMain();
        manage(main);
    }
    
    private void manage(SymbolArg arg){
        // TODO
    }

    private void manage(SymbolArgs args){
        // TODO
    }

    private void manage(SymbolArrSuff arrSuff){
        // TODO
    }

    private void manage(SymbolAssign assign){
        // TODO
    }

    /**
     * Declaration -> isConstant, variableName, type, value
     * @param dec
     */
    private void manage(SymbolDec dec){
        /* Possible errors:
         * 1. Set as constant but has a variable value
         * 2. type and the value's type are incompatible
         * 3. variableName already present in symbolTable at this level.
         *      This is detected INSIDE SymbolTable, but error must be caught here
         */
        SymbolType type = dec.getType();
        manage(type);
        SymbolOperation value = dec.getValue();
        manage(value);
        // Incompatible types
        if(type.getBaseType() != value.type) {
            writeError("Type incongruency with " + dec.variableName + ": "
            + value.type + " cannot be cast into " + type.getType());
            return;
        }
        // Constant declared, but value is variable.
        if(dec.isConstant && !value.isConstant){
            writeError("Cannot assign variable value to constant " + dec.variableName);
            return;
        }

        // Everything ok!
        // We add the variable to the symbol table 
        SymbolDescription description = new SymbolDescription();
        description.changeType(type);
        description.isConstant = dec.isConstant;
        // if(dec.isConstant) TODO add value to description if constant
        try{ 
            symbolTable.insertVariable(dec.variableName, description);
        } catch(SemanticException se){
            writeError(se.getMessage());
        }
    }

    /**
     * Decs: Dec/Func, Decs.1
     * @param decs
     */
    private void manage(SymbolDecs decs){
        SymbolBase dec = decs.getDeclaration();
        if(dec instanceof SymbolDec) manage((SymbolDec) dec);
        else if (dec instanceof SymbolFunc) manage((SymbolFunc) dec);
        else // Impossible case. Here as a safeguard to notify us if we did something wrong.
            System.err.println(" !!! Compiler error !!!");
        
        SymbolDecs nextDecs = decs.getNext();
        if (nextDecs != null) manage(nextDecs);
    }

    private void manage(SymbolElse sElse){
        // TODO
    }

    private void manage(SymbolFor sFor){
        // TODO
    }

    private void manage(SymbolFunc func){
        // TODO
    }

    private void manage(SymbolFuncCall functionCall){
        // TODO
    }

    private void manage(SymbolIf sIf){
        // TODO
    }

    private void manage(SymbolIn in){
        // TODO
    }

    private void manage(SymbolInstr instruction){
        // TODO
    }

    private void manage(SymbolInstrs instructions){
        // TODO
    }

    private void manage(SymbolList list){
        // TODO
    }

    private void manage(SymbolLoop loop){
        // TODO
    }

    private void manage(SymbolMain main){
        // TODO
    }

    private void manage(SymbolOp op){
        // TODO
    }

    private void manage(SymbolOperand operand){
        // TODO
    }

    private void manage(SymbolOperation operation){
        // TODO
    }

    private void manage(SymbolOut out){
        // TODO
    }

    private void manage(SymbolParams params){
        // TODO
    }

    private void manage(SymbolReturn sReturn){
        // TODO
    }

    private void manage(SymbolSwap swap){
        // TODO
    }

    private void manage(SymbolType type){
        // TODO
    }

    private void manage(SymbolValue value){
        // TODO
    }

    private void manage(SymbolVar var){
        // TODO
    }

    private void writeError(String errorMessage){
        thereIsError = true;
        System.err.println(errorMessage);
        errors.add(errorMessage);
    }

}
